class(datpre)
filter(dat, prefact >1)
dat$prefact
install.packages("dplyr")
library(dplyr)
dtemp <- dat %>% filter(prefact == inum)
dtemp
class(dtemp)
dtemppre <- dat %>% filter(prefact == inum)
dtemppost <- dat %>% dplyr::filter(postfact == inum)
dtemppost
length(dtemppost)
dtemppost@data
nrow(dtemppost)
inum=2
dtemppre <- dat %>% dplyr::filter(prefact == inum)#
	dtemppost <- dat %>% dplyr::filter(postfact == inum)
nrow(dtemppost) == 0
nrow(dtemppost)
dtemppost
dmat <- st_distance(dtemppre, dtemppost)
dmat
dim(dmat)
nrow(dtemppre)
apply(dmat, 1, min)
getmindist <- function(inum, dat){#
	dtemppre <- dat %>% dplyr::filter(prefact == inum)#
	dtemppost <- dat %>% dplyr::filter(postfact == inum)#
#
	if (nrow(dtemppost) == 0){#
		dtemppre$dist <- Inf#
	} else {#
		dmat <- st_distance(dtemppre, dtemppost)#
		dtemppre$dist <- apply(dmat, 1, min)#
	}#
	dtemppre#
}
unq
xout <- purrr::map(unq, ~getmindist(.x, dat))
xout
dvocc <- rbind(xout)
dvocc
dvocc <- do.call("rbind", xout)
dvocc
plot(dvocc)
xout
plot(dvocc["dist"])
dvocc$dist
plot(dvocc["dist"])
dvocc$dist[is.infinite(dvocc$dist)]
dvocc$dist[is.infinite(dvocc$dist)] <- NA
plot(dvocc["dist"])
raster(dvocc)
yrdiff <- 50
dvocc$vocc <- (dvocc$dist/1000)/yrdiff
dvocc$vocc
spvocc <- as(dvocc, "Spatial")
rasterize(spvocc, "vocc")
?rasterize
rasterize(spvocc, pre, field = "vocc")
getmindist <- function(inum, dat){#
	dtemppre <- dat %>% dplyr::filter(prefact == inum)#
	dtemppost <- dat %>% dplyr::filter(postfact == inum)#
#
	if (nrow(dtemppost) == 0){#
		dtemppre$dist <- NA#
	} else {#
		dmat <- st_distance(dtemppre, dtemppost)#
		dtemppre$dist <- apply(dmat, 1, min)#
	}#
	dtemppre#
}#
#
xout <- purrr::map(unq, ~getmindist(.x, dat))#
#
dvocc <- do.call("rbind", xout)#
yrdiff <- 50#
dvocc$vocc <- (dvocc$dist/1000)/yrdiff#
spvocc <- as(dvocc, "Spatial")#
rasterize(spvocc, pre, field = "vocc")
spvocc
spvocc$vocc
pre
getmindist <- function(inum, dat, infval = -9999){#
	dtemppre <- dat %>% dplyr::filter(prefact == inum)#
	dtemppost <- dat %>% dplyr::filter(postfact == inum)#
#
	if (nrow(dtemppost) == 0){#
		dtemppre$dist <- infval#
	} else {#
		dmat <- st_distance(dtemppre, dtemppost)#
		dtemppre$dist <- apply(dmat, 1, min)#
	}#
	dtemppre#
}
xout <- purrr::map(unq, ~getmindist(.x, dat))#
#
dvocc <- do.call("rbind", xout)#
yrdiff <- 50#
dvocc$vocc <- (dvocc$dist/1000)/yrdiff#
spvocc <- as(dvocc, "Spatial")#
rasterize(spvocc, pre, field = "vocc")
r <- rasterize(spvocc, pre, field = "vocc")
plot(r)
spvocc
plot(r)#
plot(spvocc, add = T)
r
getmindist <- function(inum, dat, infval = Inf){#
	dtemppre <- dat %>% dplyr::filter(prefact == inum)#
	dtemppost <- dat %>% dplyr::filter(postfact == inum)#
#
	if (nrow(dtemppost) == 0){#
		dtemppre$dist <- infval#
	} else {#
		dmat <- st_distance(dtemppre, dtemppost)#
		dtemppre$dist <- apply(dmat, 1, min)#
	}#
	dtemppre#
}#
#
xout <- purrr::map(unq, ~getmindist(.x, dat))#
#
dvocc <- do.call("rbind", xout)#
yrdiff <- 50#
dvocc$vocc <- (dvocc$dist/1000)/yrdiff#
spvocc <- as(dvocc, "Spatial")
r <- rasterize(spvocc, pre, field = "vocc")
plot(r)
r
plot(r)
plot(spvocc, add = T)
plot(r)
vignette("vocc")
plot(r)
# Run VoCC distance method#
# CJ Brown 2018-01-12#
# Based on Hamann et al. 2015 GCB#
#
rm(list = ls())#
library(RColorBrewer)#
library(raster)#
library(sf)#
library(dplyr)#
#
devtools::load_all("~/Code/geoengineering/vocc")#
data(sst)#
proj4string(sst) <- sp::CRS("+init=epsg:4326")#
#
##
# Distance method functions#
##
#
.getmindist <- function(inum, dat){#
	dtemppre <- dat %>% dplyr::filter(prefact == inum)#
	dtemppost <- dat %>% dplyr::filter(postfact == inum)#
#
	if (nrow(dtemppost) == 0){#
		dtemppre$dist <- Inf#
	} else {#
		dmat <- st_distance(dtemppre, dtemppost)#
		dtemppre$dist <- apply(dmat, 1, min)#
	}#
	dtemppre#
}#
distvocc <- function(pre, post, tdiff, tol, denom = 1){#
#
	names(pre) <- "prevar"#
	names(post) <- "postvar"#
#
	datpre <- raster::rasterToPoints(pre, spatial = T) %>%#
		sf::st_as_sf()#
	datpost <- raster::rasterToPoints(post, spatial = T) %>%#
	sf::st_as_sf()#
#
	dat <- sf::st_join(datpre, datpost)#
	ymin <- min(c(datpre$prevar, datpre$postvar))#
	ymax <- max(c(datpre$prevar, datpre$postvar))#
	breaks <- seq(ymin-tol, ymax+tol, by = tol)#
#
	dat$prefact <- cut(dat$pre, breaks = breaks, labels = FALSE)#
	dat$postfact <- cut(dat$post, breaks = breaks, labels = FALSE)#
#
	unq <- unique(dat$prefact)#
	xout <- purrr::map(unq, ~.getmindist(.x, dat))#
#
	dvocc <- do.call("rbind", xout)#
	dvocc$vocc <- (dvocc$dist/denom)/tdiff#
	spvocc <- as(dvocc, "Spatial")#
	r <- raster::rasterize(spvocc, pre, field = "vocc")#
	return(r)#
}#
#
##
# Implement#
##
#
tol <- 0.1#
#
pre <- raster(sst,1)#
post <- raster(sst, 50)#
tdiff <- 50#
units <- 1000 #convert to km
rvocc <- distvocc(pre, post, tdiff, tol, denom = units)
plot(rvocc)
rvocc
# Run VoCC distance method#
# CJ Brown 2018-01-12#
# Based on Hamann et al. 2015 GCB#
#
rm(list = ls())#
library(RColorBrewer)#
library(raster)#
library(sf)#
library(dplyr)#
#
devtools::load_all("~/Code/geoengineering/vocc")#
data(sst)#
proj4string(sst) <- sp::CRS("+init=epsg:4326")#
#
##
# Distance method functions#
##
#
.getmindist <- function(inum, dat, distfun = st_distance, ...){#
	dtemppre <- dat %>% dplyr::filter(prefact == inum)#
	dtemppost <- dat %>% dplyr::filter(postfact == inum)#
#
	if (nrow(dtemppost) == 0){#
		dtemppre$dist <- Inf#
	} else {#
		dmat <- distfun(dtemppre, dtemppost, ...)#
		dtemppre$dist <- apply(dmat, 1, min)#
	}#
	dtemppre#
}#
distvocc <- function(pre, post, tdiff, tol, denom = 1, distfun = st_distance, ...){#
#
	names(pre) <- "prevar"#
	names(post) <- "postvar"#
#
	datpre <- raster::rasterToPoints(pre, spatial = T) %>%#
		sf::st_as_sf()#
	datpost <- raster::rasterToPoints(post, spatial = T) %>%#
	sf::st_as_sf()#
#
	dat <- sf::st_join(datpre, datpost)#
	ymin <- min(c(datpre$prevar, datpre$postvar))#
	ymax <- max(c(datpre$prevar, datpre$postvar))#
	breaks <- seq(ymin-tol, ymax+tol, by = tol)#
#
	dat$prefact <- cut(dat$pre, breaks = breaks, labels = FALSE)#
	dat$postfact <- cut(dat$post, breaks = breaks, labels = FALSE)#
#
	unq <- unique(dat$prefact)#
	xout <- purrr::map(unq, ~.getmindist(.x, dat, distfun = st_distance, ...))#
#
	dvocc <- do.call("rbind", xout)#
	dvocc$vocc <- (dvocc$dist/denom)/tdiff#
	spvocc <- as(dvocc, "Spatial")#
	r <- raster::rasterize(spvocc, pre, field = "vocc")#
	return(r)#
}#
#
##
# Implement#
##
#
data(sst)#
tol <- 0.1
pre <- raster(sst,1)#
post <- raster(sst, 50)#
tdiff <- 50#
units <- 1000 #convert to km#
#
rvocc <- distvocc(pre, post, tdiff, tol, denom = units)
plot(rvocc)
tol <- 0.5#
#
pre <- raster(sst,1)#
post <- raster(sst, 50)#
tdiff <- 50#
units <- 1000 #convert to km#
#
rvocc <- distvocc(pre, post, tdiff, tol, denom = units)#
plot(rvocc)
class(st_distance)
proj4string(pre)
proj4string(pre) != NA
!is.na(proj4string(pre))
?st_distance
library(vocc)
?vocc
?calcvelocityi
?calcvelocity
class(datpre)
citation("boral")
citation("vocc")
getwd()
devtools::build_vignettes("~/Code/geoengineering/vocc")
devtools::build("~/Code/geoengineering/vocc")
#' Calculate velocity of climate change using the nearest distance method#
#'#
#' @usage distvocc(pre, post, tdiff, tol, denom = 1,#
#'   distfun = st_distance, ...)#
#'#
#' @param pre \code{raster} giving raster of initial climate conditions#
#' @param post \code{raster} giving raster of future climate conditions#
#' @param tdiff \code{numeric} giving time difference between pre and post#
#' @param tol \code{numeric} giving tolerance for classification of#
#' analogous climate conditions.#
#' @param denom \code{numeric} giving time giving denominator for#
#' conversion of distance units (default is metres)#
#' @param distfun \code{function} that will calculate distances between#
#' analogous climate conditions.#
#' @param ... \code{function} other parameters passed to \code{distfun}#
#'#
#' @return \code{raster} with the velocity of climate change.#
#' Default units are metres per unit time (in units of \code{tdiff}).#
#'#
#' @details This algorithm is based on the one described in#
#' Hamann et al. 2015 Velocity of climate change algorithms for#
#' guiding conservation and management. Global Change Biology 21: 997-1004#
#' The primary difference is that we use spatial data structures from#
#' \code{raster} and \code{sf} in the calculations, we use the \code{cut}#
#' function to identify analogous climate conditions, whereas Hamann et al. used rounding, and we allow flexible specification of the calculation of distances.#
#' As a consequence you must specify the projection of input raster layers.#
#' \code{pre} and \code{post} must be matching rasters and#
#' must contain CRS details (i.e. \code{!is.na(proj4string(pre))}).#
#'#
#' The default distance is the euclidean distance or, in the case of unprojected#
#' coordinates the great circle distance calculated using the#
#' \code{st_distance()} function.#
#' User defined distance functions should take \code{sf} points objects for#
#' the historical and future conditions as the first two arguments#
#' respectively.#
#'#
#' @author Christopher J. Brown#
#' @examples#
#' data(sst)#
#' tol <- 0.1#
#' pre <- raster(sst,1)#
#' post <- raster(sst, 50)#
#' tdiff <- 50#
#' units <- 1000 #convert to km#
#' rvocc <- distvocc(pre, post, tdiff, tol, denom = units)#
#' plot(rvocc)#
#' @rdname distvocc#
#' @export#
#
distvocc <- function(pre, post, tdiff, tol, denom = 1, distfun = st_distance, ...){#
#
	names(pre) <- "prevar"#
	names(post) <- "postvar"#
#
	datpre <- raster::rasterToPoints(pre, spatial = T) %>%#
		sf::st_as_sf()#
	datpost <- raster::rasterToPoints(post, spatial = T) %>%#
	sf::st_as_sf()#
#
	dat <- sf::st_join(datpre, datpost)#
	ymin <- min(c(datpre$prevar, datpre$postvar))#
	ymax <- max(c(datpre$prevar, datpre$postvar))#
	breaks <- seq(ymin-tol, ymax+tol, by = tol)#
#
	dat$prefact <- cut(dat$pre, breaks = breaks, labels = FALSE)#
	dat$postfact <- cut(dat$post, breaks = breaks, labels = FALSE)#
#
	unq <- unique(dat$prefact)#
	xout <- purrr::map(unq, ~.getmindist(.x, dat, distfun = st_distance, ...))#
#
	dvocc <- do.call("rbind", xout)#
	dvocc$vocc <- (dvocc$dist/denom)/tdiff#
	spvocc <- as(dvocc, "Spatial")#
	r <- raster::rasterize(spvocc, pre, field = "vocc")#
	return(r)#
}
devtools::build("~/Code/geoengineering/vocc")
devtools::load_all("~/Code/geoengineering/vocc")
devtools::build("~/Code/geoengineering/vocc")
devtools::install(build_vignette = FALSE)
devtools::install("~/Code/geoengineering/vocc", build_vignette = FALSE)
devtools::build("~/Code/geoengineering/vocc")
library(vocc)
?distvocc
devtools::build("~/Code/geoengineering/vocc")
?devtools::install
devtools::install("~/Code/geoengineering/vocc", build_vignette = FALSE)
library(vocc)
?distvocc
#' Calculate velocity of climate change using the nearest distance method#
#'#
#' @usage distvocc(pre, post, tdiff, tol, denom = 1,#
#'   distfun = st_distance, ...)#
#'#
#' @param pre \code{raster} giving raster of initial climate conditions#
#' @param post \code{raster} giving raster of future climate conditions#
#' @param tdiff \code{numeric} giving time difference between pre and post#
#' @param tol \code{numeric} giving tolerance for classification of#
#' analogous climate conditions.#
#' @param denom \code{numeric} giving time giving denominator for#
#' conversion of distance units (default is metres)#
#' @param distfun \code{function} that will calculate distances between#
#' analogous climate conditions.#
#' @param ... \code{function} other parameters passed to \code{distfun}#
#'#
#' @return \code{raster} with the velocity of climate change.#
#' Default units are metres per unit time (in units of \code{tdiff}).#
#'#
#' @details This algorithm is based on the one described in#
#' Hamann et al. 2015 Velocity of climate change algorithms for#
#' guiding conservation and management. Global Change Biology 21: 997-1004#
#' The primary difference is that we use spatial data structures from#
#' \code{raster} and \code{sf} in the calculations, we use the \code{cut}#
#' function to identify analogous climate conditions, whereas Hamann et al. used rounding, and we allow flexible specification of the calculation of distances.#
#' As a consequence you must specify the projection of input raster layers.#
#' \code{pre} and \code{post} must be matching rasters and#
#' must contain CRS details (i.e. \code{!is.na(proj4string(pre))}).#
#'#
#' The default distance is the euclidean distance or, in the case of unprojected#
#' coordinates the great circle distance calculated using the#
#' \code{st_distance()} function.#
#' User defined distance functions should take \code{sf} points objects for#
#' the historical and future conditions as the first two arguments#
#' respectively.#
#'#
#' @author Christopher J. Brown#
#' @examples#
#' data(sst)#
#' tol <- 0.1#
#' pre <- raster(sst,1)#
#' post <- raster(sst, 50)#
#' tdiff <- 50#
#' units <- 1000 #convert to km#
#' rvocc <- distvocc(pre, post, tdiff, tol, denom = units)#
#' plot(rvocc)#
#' @rdname distvocc#
#' @export#
#
distvocc <- function(pre, post, tdiff, tol, denom = 1, distfun = st_distance, ...){#
#
	names(pre) <- "prevar"#
	names(post) <- "postvar"#
#
	datpre <- raster::rasterToPoints(pre, spatial = T) %>%#
		sf::st_as_sf()#
	datpost <- raster::rasterToPoints(post, spatial = T) %>%#
	sf::st_as_sf()#
#
	dat <- sf::st_join(datpre, datpost)#
	ymin <- min(c(datpre$prevar, datpre$postvar))#
	ymax <- max(c(datpre$prevar, datpre$postvar))#
	breaks <- seq(ymin-tol, ymax+tol, by = tol)#
#
	dat$prefact <- cut(dat$pre, breaks = breaks, labels = FALSE)#
	dat$postfact <- cut(dat$post, breaks = breaks, labels = FALSE)#
#
	unq <- unique(dat$prefact)#
	xout <- purrr::map(unq, ~.getmindist(.x, dat, distfun = st_distance, ...))#
#
	dvocc <- do.call("rbind", xout)#
	dvocc$vocc <- (dvocc$dist/denom)/tdiff#
	spvocc <- as(dvocc, "Spatial")#
	r <- raster::rasterize(spvocc, pre, field = "vocc")#
	return(r)#
}
?distvocc
??distvocc
?vocc
devtools::install("~/Code/geoengineering/vocc", build_vignette = FALSE)
library(vocc)
??distvocc
?distvocc
?devtools::install
devtools::load_all("~/Code/geoengineering/vocc")
?distvocc
devtools::load_all("~/Code/geoengineering/vocc")
?distvocc
?spatialgrad
distvocc <- function(pre, post, tdiff, tol, denom = 1, distfun = st_distance, ...){#
#
	names(pre) <- "prevar"#
	names(post) <- "postvar"#
#
	datpre <- raster::rasterToPoints(pre, spatial = T) %>%#
		sf::st_as_sf()#
	datpost <- raster::rasterToPoints(post, spatial = T) %>%#
	sf::st_as_sf()#
#
	dat <- sf::st_join(datpre, datpost)#
	ymin <- min(c(datpre$prevar, datpre$postvar))#
	ymax <- max(c(datpre$prevar, datpre$postvar))#
	breaks <- seq(ymin-tol, ymax+tol, by = tol)#
#
	dat$prefact <- cut(dat$pre, breaks = breaks, labels = FALSE)#
	dat$postfact <- cut(dat$post, breaks = breaks, labels = FALSE)#
#
	unq <- unique(dat$prefact)#
	xout <- purrr::map(unq, ~.getmindist(.x, dat, distfun = st_distance, ...))#
#
	dvocc <- do.call("rbind", xout)#
	dvocc$vocc <- (dvocc$dist/denom)/tdiff#
	spvocc <- as(dvocc, "Spatial")#
	r <- raster::rasterize(spvocc, pre, field = "vocc")#
	return(r)#
	}
distvocc
devtools::install_github("cbrown5/vocc")
vignette("vocc")
?distvocc
.lm
?.lm
?lm
?.lm.fit
p <- c(0.3, 0.3, 0.4)
q <- c(0.05, 0.9, 0.05)
sum(p*log2(p))
sum(q*log2(q))
-sum(p*log2(p))
-sum(q*log2(q))
sum(p*log2(p/1))
sum(p*log2(p/q))
sum(q*log2(q/p))
350*8
850*8
850*7
31.6*1.2
library(purrr)
rm(list = ls())#
library(simmr)#
library(purrr)#
library(dplyr)#
devtools::load_all("~/Code/isotope mixing models/remixsiar")#
#
##
# Load data#
##
#
load("isotope mixing models/remixsiar/data-raw/sims/Multi_n_runs_gulls.Rdata")#
load("isotope mixing models/remixsiar/data-raw/sims/Multi_n_runs_gulls_biased.Rdata")#
load("isotope mixing models/remixsiar/data-raw/sims/Multi_n_runs_gulls_infprior.Rdata")#
load("isotope mixing models/remixsiar/data-raw/sims/dfin.Rdata")#
load("isotope mixing models/remixsiar/data-raw/sims/dfin_biased.Rdata")#
load("isotope mixing models/remixsiar/data-raw/sims/dfin_infprior.Rdata")#
#
load("isotope mixing models/remixsiar/data-raw/sims/gulls_informative_prior.RData")#
#
sdat <- read.csv("isotope mixing models/remixsiar/data-raw/gull_sources.csv")
rout <- map(1:length(gulls_multirun), ~calchell(gulls_multirun[[.x]]))#
#
rdf <- do.call(rbind, rout) %>% data.frame() %>%#
setNames(paste0('hd', as.character(sdat$source))) %>%#
 cbind(dfin)#
#
kout <- map(1:length(gulls_multirun), ~calckl(gulls_multirun[[.x]]))#
#
kdf <- do.call(rbind, kout) %>% data.frame() %>%#
setNames(paste0('hk', as.character(sdat$source))) %>%#
 cbind(dfin) %>% left_join(rdf)#
#
vbout <- map(1:length(gulls_multirun), ~calcvarbia(gulls_multirun[[.x]]))#
vbdf <- do.call(rbind, vbout) %>% data.frame() %>%#
 cbind(dfin) %>% left_join(kdf)#
#
rdsum <- vbdf %>% group_by(n, sdmult) %>%#
summarize_all(funs(mean, sd)) %>% select(-contains("seed"))#
#
datforplots <- list(basic = rdsum)
load("isotope mixing models/remixsiar/data-raw/sims/Multi_n_runs_gulls.Rdata")#
load("isotope mixing models/remixsiar/data-raw/sims/Multi_n_runs_gulls_biased.Rdata")
getwd()
setwd("~/Code")
load("isotope mixing models/remixsiar/data-raw/sims/Multi_n_runs_gulls.Rdata")
load("isotope mixing models/remixsiar/data-raw/sims/Multi_n_runs_gulls_biased.Rdata")
load("isotope mixing models/remixsiar/data-raw/sims/dfin.Rdata")
sdat <- read.csv("isotope mixing models/remixsiar/data-raw/gull_sources.csv")
dev.new(); plot(gulls_multirun[[which(dfin$sdmult == 1 & dfin$n==40)[1]]][[2]], "boxplot")#
dev.new(); plot(gulls_multirun_infprior[[which(dfin2$n==40)[1]]][[2]], "boxplot")
##
# gulls example plot#
##
#
dev.new(); plot(gulls_multirun[[which(dfin$sdmult == 1 & dfin$n==40)[1]]][[1]])#
dev.new(); plot(gulls_multirun[[which(dfin$sdmult == 1 & dfin$n==40)[1]]][[2]], 'density')
gpd <- drawpriors(gulls_multirun[[1]]$gulls_in,  default_prior(gulls_multirun[[1]]$gulls_in))#
xy <- hist(gpd$Krill, breaks = 101, plot = F)#
ntot <- sum(xy$counts)#
Hmax <- -sum((xy$counts / ntot) * log2(xy$counts/ntot))#
#
# ------------ ##
# Normal data#
# ------------ ##
#
##
# Calc inf metrics across simulations#
##
#
rout <- map(1:length(gulls_multirun), ~calchell(gulls_multirun[[.x]]))#
#
rdf <- do.call(rbind, rout) %>% data.frame() %>%#
setNames(paste0('hd', as.character(sdat$source))) %>%#
 cbind(dfin)
rm(list = ls())#
library(ggplot2)#
library(simmr)#
library(purrr)#
library(dplyr)#
library(grid)#
library(png)#
#
library(RColorBrewer)#
devtools::load_all("~/Code/isotope mixing models/remixsiar")#
#
load("isotope mixing models/remixsiar/data-raw/sims/GullsSummary.rda")#
load("isotope mixing models/remixsiar/data-raw/sims/max_entropy.rda")#
#
rdsum <- datforplots$basic
#Plots, eventually turn this into a child#
#```{r}#
rm(list = ls())#
library(ggplot2)#
library(simmr)#
library(purrr)#
library(dplyr)#
library(grid)#
library(png)#
#
library(RColorBrewer)#
devtools::load_all("~/Code/isotope mixing models/remixsiar")#
#
load("isotope mixing models/remixsiar/data-raw/sims/GullsSummary.rda")#
load("isotope mixing models/remixsiar/data-raw/sims/max_entropy.rda")#
#
rdsum <- datforplots$basic
load("isotope mixing models/remixsiar/data-raw/sims/GullsSummary.rda")
# Plots for gulls simulations#
# CJ Brown 16 Feb 2017#
#
rm(list = ls())#
library(simmr)#
library(purrr)#
library(dplyr)#
devtools::load_all("~/Code/isotope mixing models/remixsiar")#
#
##
# Load data#
##
#
load("isotope mixing models/remixsiar/data-raw/sims/Multi_n_runs_gulls.Rdata")#
load("isotope mixing models/remixsiar/data-raw/sims/Multi_n_runs_gulls_biased.Rdata")#
load("isotope mixing models/remixsiar/data-raw/sims/Multi_n_runs_gulls_infprior.Rdata")#
load("isotope mixing models/remixsiar/data-raw/sims/dfin.Rdata")#
load("isotope mixing models/remixsiar/data-raw/sims/dfin_biased.Rdata")#
load("isotope mixing models/remixsiar/data-raw/sims/dfin_infprior.Rdata")#
#
load("isotope mixing models/remixsiar/data-raw/sims/gulls_informative_prior.RData")#
#
sdat <- read.csv("isotope mixing models/remixsiar/data-raw/gull_sources.csv")#
#
##
# Plot results from equivalent runs#
##
#
dev.new(); plot(gulls_multirun[[which(dfin$sdmult == 1 & dfin$n==40)[1]]][[2]], "boxplot")#
dev.new(); plot(gulls_multirun_infprior[[which(dfin2$n==40)[1]]][[2]], "boxplot")#
##
# gulls example plot#
##
#
dev.new(); plot(gulls_multirun[[which(dfin$sdmult == 1 & dfin$n==40)[1]]][[1]])#
dev.new(); plot(gulls_multirun[[which(dfin$sdmult == 1 & dfin$n==40)[1]]][[2]], 'density')#
##
# Max KL#
##
gpd <- drawpriors(gulls_multirun[[1]]$gulls_in,  default_prior(gulls_multirun[[1]]$gulls_in))#
xy <- hist(gpd$Krill, breaks = 101, plot = F)#
ntot <- sum(xy$counts)#
Hmax <- -sum((xy$counts / ntot) * log2(xy$counts/ntot))#
#
# ------------ ##
# Normal data#
# ------------ ##
#
##
# Calc inf metrics across simulations#
##
#
rout <- map(1:length(gulls_multirun), ~calchell(gulls_multirun[[.x]]))#
#
rdf <- do.call(rbind, rout) %>% data.frame() %>%#
setNames(paste0('hd', as.character(sdat$source))) %>%#
 cbind(dfin)#
#
kout <- map(1:length(gulls_multirun), ~calckl(gulls_multirun[[.x]]))#
#
kdf <- do.call(rbind, kout) %>% data.frame() %>%#
setNames(paste0('hk', as.character(sdat$source))) %>%#
 cbind(dfin) %>% left_join(rdf)#
#
vbout <- map(1:length(gulls_multirun), ~calcvarbia(gulls_multirun[[.x]]))#
vbdf <- do.call(rbind, vbout) %>% data.frame() %>%#
 cbind(dfin) %>% left_join(kdf)#
#
rdsum <- vbdf %>% group_by(n, sdmult) %>%#
summarize_all(funs(mean, sd)) %>% select(-contains("seed"))#
#
datforplots <- list(basic = rdsum)#
# ------------ ##
# Informative prior#
# ------------ ##
#
gpd <- drawpriors(gulls_multirun_infprior[[1]]$dat_in,  ginfprior)#
#
Hmax_inf <- rep(NA, 3)#
for(i in 1:3){#
    xy <- hist(gpd[,i], breaks = 101, plot = F)#
    ntot <- sum(xy$counts)#
    Hmax_inf[i] <- -sum(na.omit((xy$counts / ntot) * log2(xy$counts/ntot)))#
}#
#
rout <- map(1:length(gulls_multirun_infprior), ~calchell(gulls_multirun_infprior[[.x]], dp = ginfprior))#
rdf <- do.call(rbind, rout) %>% data.frame() %>%#
setNames(paste0('hd', as.character(sdat$source))) %>%#
 cbind(dfin2)#
#
kout <- map(1:length(gulls_multirun_infprior), ~calckl(gulls_multirun_infprior[[.x]], dp = ginfprior))#
#
kdf <- do.call(rbind, kout) %>% data.frame() %>%#
setNames(paste0('hk', as.character(sdat$source))) %>%#
 cbind(dfin2) %>% left_join(rdf)#
#
vbout <- map(1:length(gulls_multirun_infprior), ~calcvarbia(gulls_multirun_infprior[[.x]]))#
vbdf <- do.call(rbind, vbout) %>% data.frame() %>%#
 cbind(dfin2) %>% left_join(kdf)#
#
rdsum <- vbdf %>% group_by(n) %>%#
summarize_all(funs(mean, sd)) %>% select(-contains("seed"))#
#
datforplots <- c(datforplots, list(infprior = rdsum))#
#
# ------------ ##
# Biased data#
# ------------ ##
#
rout <- map(1:length(gulls_multirun_biased), ~calchell(gulls_multirun_biased[[.x]]))#
rdf <- do.call(rbind, rout) %>% data.frame() %>%#
setNames(paste0('hd', as.character(sdat$source))) %>%#
 cbind(dfin2)#
#
kout <- map(1:length(gulls_multirun_biased), ~calckl(gulls_multirun_biased[[.x]]))#
#
kdf <- do.call(rbind, kout) %>% data.frame() %>%#
setNames(paste0('hk', as.character(sdat$source))) %>%#
 cbind(dfin2) %>% left_join(rdf)#
#
vbout <- map(1:length(gulls_multirun_biased), ~calcvarbia(gulls_multirun_biased[[.x]]))#
vbdf <- do.call(rbind, vbout) %>% data.frame() %>%#
 cbind(dfin2) %>% left_join(kdf)#
#
rdsum <- vbdf %>% group_by(n) %>%#
summarize_all(funs(mean, sd)) %>% select(-contains("seed"))#
#
datforplots <- c(datforplots, list(biased = rdsum))#
#
##
# Save summary data#
##
#
save(datforplots,#
    file = "isotope mixing models/remixsiar/data-raw/sims/GullsSummary.rda")#
hmax <- list(Hmax = Hmax, Hmax_inf = Hmax_inf)#
save(hmax,#
    file = "isotope mixing models/remixsiar/data-raw/sims/max_entropy.rda")
#Plots, eventually turn this into a child#
#```{r}#
rm(list = ls())#
library(ggplot2)#
library(simmr)#
library(purrr)#
library(dplyr)#
library(grid)#
library(png)#
#
library(RColorBrewer)#
devtools::load_all("~/Code/isotope mixing models/remixsiar")#
#
load("isotope mixing models/remixsiar/data-raw/sims/GullsSummary.rda")#
load("isotope mixing models/remixsiar/data-raw/sims/max_entropy.rda")#
#
rdsum <- datforplots$basic#
##
# ggplot theme#
##
#
theme_plain <- function(base_size = 12){#
    structure(list(#
        theme(#
        panel.grid.major = element_blank(),#
         panel.grid.minor = element_blank(),#
        strip.text=element_text(hjust=0.05),#
        strip.background = element_rect(fill='white', colour = 'white'),#
        axis.line = element_line(color = "black"),#
        axis.ticks.length = unit(0.25, "cm"),#
        plot.background =   element_rect(colour = "white", fill = "white"),#
        axis.text = element_text(size = base_size * 1.2 ,#
            lineheight = 1.1, colour = "black", vjust = 1, margin = unit(0.1, "lines")),#
        panel.background = element_rect(fill = "white", colour = NA)#
        )#
      ), class = "options")#
}#
#
infotheme <- list(#
    geom_line(),#
    theme_plain(),#
     scale_colour_manual(values = cols,#
        name = "SD of sources \n (relative)"),#
    scale_fill_manual(values = cols_alpha),#
    xlab("Sample size"),#
    scale_x_continuous(expand = c(0.01,0),#
    breaks = seq(0, 200, by = 25),#
    limits = c(0, 200))#
)#
##
# Base plot#
##
cols <- RColorBrewer::brewer.pal(6, 'Blues')[4:6]#
cols_alpha <- PlotTools::hexalpha(cols, 0.5) %>% as.character()#
asz <- 5#
ah <- -1#
av <- 1#
#
p1 <- ggplot(rdsum, aes(x = n, y = hdMussels_mean,#
    group = factor(sdmult),#
    color = factor(sdmult))) +#
    geom_ribbon(aes(ymin = hdMussels_mean - hdMussels_sd, ymax = hdMussels_mean + hdMussels_sd, fill = factor(sdmult),#
    colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = seq(0, 1, by = 0.25), limits = c(0,1)) +#
infotheme +#
ylab("Hellinger distance") +#
annotate("text", x = -Inf, y =Inf, label = "a", vjust = av, hjust = ah, size = asz)#
#
p2 <- ggplot(rdsum, aes(x = n, y = hkMussels_mean, group = factor(sdmult),#
color = factor(sdmult))) +#
geom_ribbon(aes(ymin = hkMussels_mean - hkMussels_sd, ymax = hkMussels_mean + hkMussels_sd, fill = factor(sdmult),#
colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = seq(0, ceiling(hmax$Hmax), by = 1), limits = c(0,ceiling(hmax$Hmax))) +#
infotheme +#
ylab("Kullback-Leibler divergence (bits)") +#
geom_hline(yintercept = hmax$Hmax, linetype = 2) +#
annotate("text", x = 50, y = hmax$Hmax, vjust = 1.5,#
label = "Maximum entropy")+#
annotate("text", x = -Inf, y =Inf, label = "b", vjust = av, hjust = ah, size = asz)#
p3 <- ggplot(rdsum, aes(x = n, y = bias_n_mean, group = factor(sdmult),#
color = factor(sdmult))) +#
 geom_ribbon(aes(ymin = bias_n_mean - bias_n_sd, ymax = bias_n_mean + bias_n_sd, fill = factor(sdmult),#
colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = round(seq(-0.35, 0.35, by = 0.1),1), limits = c(-0.35,0.35)) +#
infotheme +#
ylab(expression(paste("Bias for ",delta^15, "N (\u2030)",sep="")))+#
annotate("text", x = -Inf, y =Inf, label = "c", vjust = av, hjust = ah, size = asz)#
#
p4 <- ggplot(rdsum, aes(x = n, y = rmse_n_mean, group = factor(sdmult),#
color = factor(sdmult))) +#
 geom_ribbon(aes(ymin = rmse_n_mean - rmse_n_sd, ymax = rmse_n_mean + rmse_n_sd, fill = factor(sdmult),#
colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = round(seq(0, 0.4, by = 0.1),1), limits = c(0, 0.4)) +#
infotheme +#
ylab(expression(paste("RMSE for ",delta^15, "N (\u2030)",sep=""))) +#
annotate("text", x = -Inf, y =Inf, label = "d", vjust = av, hjust = ah, size = asz)#
#
layout <- matrix(seq(1, 4), ncol = 2, nrow = 2, byrow = T)#
png(filename = "isotope mixing models/remixsiar/vignettes/ms/figures/fig2.png",#
 width = 800, height = 400)#
#grid::grid.newpage()#
grid::pushViewport(grid::viewport(layout = grid::grid.layout(nrow(layout), ncol(layout))))#
print(p1, vp = grid::viewport(layout.pos.row = 1, layout.pos.col = 1))#
print(p2, vp = grid::viewport(layout.pos.row = 1, layout.pos.col = 2))#
print(p3, vp = grid::viewport(layout.pos.row = 2, layout.pos.col = 1))#
print(p4, vp = grid::viewport(layout.pos.row = 2, layout.pos.col = 2))#
dev.off()
p2
?theme
#Plots, eventually turn this into a child#
#```{r}#
rm(list = ls())#
library(ggplot2)#
library(simmr)#
library(purrr)#
library(dplyr)#
library(grid)#
library(png)#
#
library(RColorBrewer)#
devtools::load_all("~/Code/isotope mixing models/remixsiar")#
#
load("isotope mixing models/remixsiar/data-raw/sims/GullsSummary.rda")#
load("isotope mixing models/remixsiar/data-raw/sims/max_entropy.rda")#
#
rdsum <- datforplots$basic#
##
# ggplot theme#
##
#
theme_plain <- function(base_size = 12){#
    structure(list(#
        theme(#
        panel.grid.major = element_blank(),#
         panel.grid.minor = element_blank(),#
        strip.text=element_text(hjust=0.05),#
        strip.background = element_rect(fill='white', colour = 'white'),#
        axis.title = element_text(size = base_size*1.1)#
        axis.line = element_line(color = "black"),#
        axis.ticks.length = unit(0.25, "cm"),#
        plot.background =   element_rect(colour = "white", fill = "white"),#
        axis.text = element_text(size = base_size * 1 ,#
            lineheight = 1, colour = "black", vjust = 1, margin = unit(0.1, "lines")),#
        panel.background = element_rect(fill = "white", colour = NA)#
        )#
      ), class = "options")#
}#
#
infotheme <- list(#
    geom_line(),#
    theme_plain(),#
     scale_colour_manual(values = cols,#
        name = "SD of sources \n (relative)"),#
    scale_fill_manual(values = cols_alpha),#
    xlab("Sample size"),#
    scale_x_continuous(expand = c(0.01,0),#
    breaks = seq(0, 200, by = 25),#
    limits = c(0, 200))#
)#
hmax <- 7
##
# Base plot#
##
cols <- RColorBrewer::brewer.pal(6, 'Blues')[4:6]#
cols_alpha <- PlotTools::hexalpha(cols, 0.5) %>% as.character()#
asz <- 5#
ah <- -1#
av <- 1#
#
p1 <- ggplot(rdsum, aes(x = n, y = hdMussels_mean,#
    group = factor(sdmult),#
    color = factor(sdmult))) +#
    geom_ribbon(aes(ymin = hdMussels_mean - hdMussels_sd, ymax = hdMussels_mean + hdMussels_sd, fill = factor(sdmult),#
    colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = seq(0, 1, by = 0.25), limits = c(0,1)) +#
infotheme +#
ylab("Hellinger distance") +#
annotate("text", x = -Inf, y =Inf, label = "a", vjust = av, hjust = ah, size = asz)#
#
p2 <- ggplot(rdsum, aes(x = n, y = hkMussels_mean, group = factor(sdmult),#
color = factor(sdmult))) +#
geom_ribbon(aes(ymin = hkMussels_mean - hkMussels_sd, ymax = hkMussels_mean + hkMussels_sd, fill = factor(sdmult),#
colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = seq(0, ceiling(hmax$Hmax), by = 1), limits = c(0,ceiling(hmax$Hmax))) +#
infotheme +#
ylab("Kullback-Leibler divergence (bits)") +#
geom_hline(yintercept = hmax$Hmax, linetype = 2) +#
annotate("text", x = 50, y = hmax$Hmax, vjust = 1.5,#
label = "Maximum entropy")+#
annotate("text", x = -Inf, y =Inf, label = "b", vjust = av, hjust = ah, size = asz)#
p3 <- ggplot(rdsum, aes(x = n, y = bias_n_mean, group = factor(sdmult),#
color = factor(sdmult))) +#
 geom_ribbon(aes(ymin = bias_n_mean - bias_n_sd, ymax = bias_n_mean + bias_n_sd, fill = factor(sdmult),#
colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = round(seq(-0.35, 0.35, by = 0.1),1), limits = c(-0.35,0.35)) +#
infotheme +#
ylab(expression(paste("Bias for ",delta^15, "N (\u2030)",sep="")))+#
annotate("text", x = -Inf, y =Inf, label = "c", vjust = av, hjust = ah, size = asz)#
#
p4 <- ggplot(rdsum, aes(x = n, y = rmse_n_mean, group = factor(sdmult),#
color = factor(sdmult))) +#
 geom_ribbon(aes(ymin = rmse_n_mean - rmse_n_sd, ymax = rmse_n_mean + rmse_n_sd, fill = factor(sdmult),#
colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = round(seq(0, 0.4, by = 0.1),1), limits = c(0, 0.4)) +#
infotheme +#
ylab(expression(paste("RMSE for ",delta^15, "N (\u2030)",sep=""))) +#
annotate("text", x = -Inf, y =Inf, label = "d", vjust = av, hjust = ah, size = asz)#
#
layout <- matrix(seq(1, 4), ncol = 2, nrow = 2, byrow = T)#
png(filename = "isotope mixing models/remixsiar/vignettes/ms/figures/fig2.png",#
 width = 800, height = 400)#
#grid::grid.newpage()#
grid::pushViewport(grid::viewport(layout = grid::grid.layout(nrow(layout), ncol(layout))))#
print(p1, vp = grid::viewport(layout.pos.row = 1, layout.pos.col = 1))#
print(p2, vp = grid::viewport(layout.pos.row = 1, layout.pos.col = 2))#
print(p3, vp = grid::viewport(layout.pos.row = 2, layout.pos.col = 1))#
print(p4, vp = grid::viewport(layout.pos.row = 2, layout.pos.col = 2))#
dev.off()
#Plots, eventually turn this into a child#
#```{r}#
rm(list = ls())#
library(ggplot2)#
library(simmr)#
library(purrr)#
library(dplyr)#
library(grid)#
library(png)#
#
library(RColorBrewer)#
devtools::load_all("~/Code/isotope mixing models/remixsiar")#
#
load("isotope mixing models/remixsiar/data-raw/sims/GullsSummary.rda")#
load("isotope mixing models/remixsiar/data-raw/sims/max_entropy.rda")#
#
rdsum <- datforplots$basic#
##
# ggplot theme#
##
#
theme_plain <- function(base_size = 12){#
    structure(list(#
        theme(#
        panel.grid.major = element_blank(),#
         panel.grid.minor = element_blank(),#
        strip.text=element_text(hjust=0.05),#
        strip.background = element_rect(fill='white', colour = 'white'),#
        axis.title = element_text(size = base_size*1.1),#
        axis.line = element_line(color = "black"),#
        axis.ticks.length = unit(0.25, "cm"),#
        plot.background =   element_rect(colour = "white", fill = "white"),#
        axis.text = element_text(size = base_size * 1 ,#
            lineheight = 1, colour = "black", vjust = 1, margin = unit(0.1, "lines")),#
        panel.background = element_rect(fill = "white", colour = NA)#
        )#
      ), class = "options")#
}#
#
infotheme <- list(#
    geom_line(),#
    theme_plain(),#
     scale_colour_manual(values = cols,#
        name = "SD of sources \n (relative)"),#
    scale_fill_manual(values = cols_alpha),#
    xlab("Sample size"),#
    scale_x_continuous(expand = c(0.01,0),#
    breaks = seq(0, 200, by = 25),#
    limits = c(0, 200))#
)#
hmax <- 7#
##
# Base plot#
##
cols <- RColorBrewer::brewer.pal(6, 'Blues')[4:6]#
cols_alpha <- PlotTools::hexalpha(cols, 0.5) %>% as.character()#
asz <- 5#
ah <- -1#
av <- 1#
#
p1 <- ggplot(rdsum, aes(x = n, y = hdMussels_mean,#
    group = factor(sdmult),#
    color = factor(sdmult))) +#
    geom_ribbon(aes(ymin = hdMussels_mean - hdMussels_sd, ymax = hdMussels_mean + hdMussels_sd, fill = factor(sdmult),#
    colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = seq(0, 1, by = 0.25), limits = c(0,1)) +#
infotheme +#
ylab("Hellinger distance") +#
annotate("text", x = -Inf, y =Inf, label = "a", vjust = av, hjust = ah, size = asz)#
#
p2 <- ggplot(rdsum, aes(x = n, y = hkMussels_mean, group = factor(sdmult),#
color = factor(sdmult))) +#
geom_ribbon(aes(ymin = hkMussels_mean - hkMussels_sd, ymax = hkMussels_mean + hkMussels_sd, fill = factor(sdmult),#
colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = seq(0, ceiling(hmax$Hmax), by = 1), limits = c(0,ceiling(hmax$Hmax))) +#
infotheme +#
ylab("Kullback-Leibler divergence (bits)") +#
geom_hline(yintercept = hmax$Hmax, linetype = 2) +#
annotate("text", x = 50, y = hmax$Hmax, vjust = 1.5,#
label = "Maximum entropy")+#
annotate("text", x = -Inf, y =Inf, label = "b", vjust = av, hjust = ah, size = asz)#
p3 <- ggplot(rdsum, aes(x = n, y = bias_n_mean, group = factor(sdmult),#
color = factor(sdmult))) +#
 geom_ribbon(aes(ymin = bias_n_mean - bias_n_sd, ymax = bias_n_mean + bias_n_sd, fill = factor(sdmult),#
colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = round(seq(-0.35, 0.35, by = 0.1),1), limits = c(-0.35,0.35)) +#
infotheme +#
ylab(expression(paste("Bias for ",delta^15, "N (\u2030)",sep="")))+#
annotate("text", x = -Inf, y =Inf, label = "c", vjust = av, hjust = ah, size = asz)#
#
p4 <- ggplot(rdsum, aes(x = n, y = rmse_n_mean, group = factor(sdmult),#
color = factor(sdmult))) +#
 geom_ribbon(aes(ymin = rmse_n_mean - rmse_n_sd, ymax = rmse_n_mean + rmse_n_sd, fill = factor(sdmult),#
colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = round(seq(0, 0.4, by = 0.1),1), limits = c(0, 0.4)) +#
infotheme +#
ylab(expression(paste("RMSE for ",delta^15, "N (\u2030)",sep=""))) +#
annotate("text", x = -Inf, y =Inf, label = "d", vjust = av, hjust = ah, size = asz)#
#
layout <- matrix(seq(1, 4), ncol = 2, nrow = 2, byrow = T)#
png(filename = "isotope mixing models/remixsiar/vignettes/ms/figures/fig2.png",#
 width = 800, height = 400)#
#grid::grid.newpage()#
grid::pushViewport(grid::viewport(layout = grid::grid.layout(nrow(layout), ncol(layout))))#
print(p1, vp = grid::viewport(layout.pos.row = 1, layout.pos.col = 1))#
print(p2, vp = grid::viewport(layout.pos.row = 1, layout.pos.col = 2))#
print(p3, vp = grid::viewport(layout.pos.row = 2, layout.pos.col = 1))#
print(p4, vp = grid::viewport(layout.pos.row = 2, layout.pos.col = 2))#
dev.off()
hmax <- list(Hmax = 7)
##
# Base plot#
##
cols <- RColorBrewer::brewer.pal(6, 'Blues')[4:6]#
cols_alpha <- PlotTools::hexalpha(cols, 0.5) %>% as.character()#
asz <- 5#
ah <- -1#
av <- 1#
#
p1 <- ggplot(rdsum, aes(x = n, y = hdMussels_mean,#
    group = factor(sdmult),#
    color = factor(sdmult))) +#
    geom_ribbon(aes(ymin = hdMussels_mean - hdMussels_sd, ymax = hdMussels_mean + hdMussels_sd, fill = factor(sdmult),#
    colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = seq(0, 1, by = 0.25), limits = c(0,1)) +#
infotheme +#
ylab("Hellinger distance") +#
annotate("text", x = -Inf, y =Inf, label = "a", vjust = av, hjust = ah, size = asz)#
#
p2 <- ggplot(rdsum, aes(x = n, y = hkMussels_mean, group = factor(sdmult),#
color = factor(sdmult))) +#
geom_ribbon(aes(ymin = hkMussels_mean - hkMussels_sd, ymax = hkMussels_mean + hkMussels_sd, fill = factor(sdmult),#
colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = seq(0, ceiling(hmax$Hmax), by = 1), limits = c(0,ceiling(hmax$Hmax))) +#
infotheme +#
ylab("Kullback-Leibler divergence (bits)") +#
geom_hline(yintercept = hmax$Hmax, linetype = 2) +#
annotate("text", x = 50, y = hmax$Hmax, vjust = 1.5,#
label = "Maximum entropy")+#
annotate("text", x = -Inf, y =Inf, label = "b", vjust = av, hjust = ah, size = asz)#
p3 <- ggplot(rdsum, aes(x = n, y = bias_n_mean, group = factor(sdmult),#
color = factor(sdmult))) +#
 geom_ribbon(aes(ymin = bias_n_mean - bias_n_sd, ymax = bias_n_mean + bias_n_sd, fill = factor(sdmult),#
colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = round(seq(-0.35, 0.35, by = 0.1),1), limits = c(-0.35,0.35)) +#
infotheme +#
ylab(expression(paste("Bias for ",delta^15, "N (\u2030)",sep="")))+#
annotate("text", x = -Inf, y =Inf, label = "c", vjust = av, hjust = ah, size = asz)#
#
p4 <- ggplot(rdsum, aes(x = n, y = rmse_n_mean, group = factor(sdmult),#
color = factor(sdmult))) +#
 geom_ribbon(aes(ymin = rmse_n_mean - rmse_n_sd, ymax = rmse_n_mean + rmse_n_sd, fill = factor(sdmult),#
colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = round(seq(0, 0.4, by = 0.1),1), limits = c(0, 0.4)) +#
infotheme +#
ylab(expression(paste("RMSE for ",delta^15, "N (\u2030)",sep=""))) +#
annotate("text", x = -Inf, y =Inf, label = "d", vjust = av, hjust = ah, size = asz)#
#
layout <- matrix(seq(1, 4), ncol = 2, nrow = 2, byrow = T)#
png(filename = "isotope mixing models/remixsiar/vignettes/ms/figures/fig2.png",#
 width = 800, height = 400)#
#grid::grid.newpage()#
grid::pushViewport(grid::viewport(layout = grid::grid.layout(nrow(layout), ncol(layout))))#
print(p1, vp = grid::viewport(layout.pos.row = 1, layout.pos.col = 1))#
print(p2, vp = grid::viewport(layout.pos.row = 1, layout.pos.col = 2))#
print(p3, vp = grid::viewport(layout.pos.row = 2, layout.pos.col = 1))#
print(p4, vp = grid::viewport(layout.pos.row = 2, layout.pos.col = 2))#
dev.off()
rdsum
rdsum$rmse_n_mean
ggplot(rdsum, aes(x = n, y = rmse_n_mean, group = factor(sdmult),#
color = factor(sdmult))) +#
 geom_ribbon(aes(ymin = rmse_n_mean - rmse_n_sd, ymax = rmse_n_mean + rmse_n_sd, fill = factor(sdmult),#
colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = round(seq(0, 0.4, by = 0.1),1), limits = c(0, 0.4)) +#
infotheme +#
ylab(expression(paste("RMSE for ",delta^15, "N (\u2030)",sep=""))) +#
annotate("text", x = -Inf, y =Inf, label = "d", vjust = av, hjust = ah, size = asz)
ggplot(rdsum, aes(x = n, y = rmse_n_mean, group = factor(sdmult),#
color = factor(sdmult))) +#
 geom_ribbon(aes(ymin = rmse_n_mean - rmse_n_sd, ymax = rmse_n_mean + rmse_n_sd, fill = factor(sdmult),#
colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = round(seq(0, 1.6, by = 0.1),1), limits = c(0, 1.6)) +#
infotheme +#
ylab(expression(paste("RMSE for ",delta^15, "N (\u2030)",sep=""))) +#
annotate("text", x = -Inf, y =Inf, label = "d", vjust = av, hjust = ah, size = asz)
ggplot(rdsum, aes(x = n, y = bias_n_mean, group = factor(sdmult),#
color = factor(sdmult))) +#
 geom_ribbon(aes(ymin = bias_n_mean - bias_n_sd, ymax = bias_n_mean + bias_n_sd, fill = factor(sdmult),#
colour = NA), show.legend = FALSE) +#
scale_y_continuous(expand = c(0.01, 0),#
breaks = round(seq(-0.35, 0.35, by = 0.1),1), limits = c(-0.35,0.35)) +#
infotheme +#
ylab(expression(paste("Bias for ",delta^15, "N (\u2030)",sep="")))+#
annotate("text", x = -Inf, y =Inf, label = "c", vjust = av, hjust = ah, size = asz)
rdsum
rdsum$bias_n_sd
rm(list = ls())#
library(purrr)#
library(devtools)#
library(jagstools)#
library(tidyr)#
library(ggplot2)#
library(stringr)#
library(PlotTools)#
library(dplyr)#
library(forcats)#
library(sp)#
library(rgdal)
library(raster)
load_all('~/Code/BenthicLatent')
install.packages(jagstools, dependencies = T)
install.packages("jagstools", dependencies = T)
devtools::install_github("https://github.com/johnbaums/jagstools")
?devtools::install_github
devtools::install_github("johnbaums", "jagstools")
load_all('~/Code/BenthicLatent')
.libs()
libs()
.lib()
?library
.libPaths()
# Plots for gulls simulations#
# CJ Brown 16 Feb 2017#
#
rm(list = ls())#
library(simmr)#
library(purrr)#
library(dplyr)
devtools::load_all("~/Code/isotope mixing models/remixsiar")
load("isotope mixing models/remixsiar/data-raw/sims/Multi_n_runs_gulls.Rdata")
load("isotope mixing models/remixsiar/data-raw/sims/Multi_n_runs_gulls_biased.Rdata")#
load("isotope mixing models/remixsiar/data-raw/sims/Multi_n_runs_gulls_infprior.Rdata")#
load("isotope mixing models/remixsiar/data-raw/sims/dfin.Rdata")#
load("isotope mixing models/remixsiar/data-raw/sims/dfin_biased.Rdata")#
load("isotope mixing models/remixsiar/data-raw/sims/dfin_infprior.Rdata")#
#
load("isotope mixing models/remixsiar/data-raw/sims/gulls_informative_prior.RData")#
#
sdat <- read.csv("isotope mixing models/remixsiar/data-raw/gull_sources.csv")#
#
##
# Plot results from equivalent runs#
##
#
dev.new(); plot(gulls_multirun[[which(dfin$sdmult == 1 & dfin$n==40)[1]]][[2]], "boxplot")#
dev.new(); plot(gulls_multirun_infprior[[which(dfin2$n==40)[1]]][[2]], "boxplot")#
##
# gulls example plot#
##
#
dev.new(); plot(gulls_multirun[[which(dfin$sdmult == 1 & dfin$n==40)[1]]][[1]])#
dev.new(); plot(gulls_multirun[[which(dfin$sdmult == 1 & dfin$n==40)[1]]][[2]], 'density')#
##
# Max KL#
##
#
gpd <- drawpriors(gulls_multirun[[1]]$gulls_in,  default_prior(gulls_multirun[[1]]$gulls_in))#
xy <- hist(gpd$Krill, breaks = 101, plot = F)#
ntot <- sum(xy$counts)#
Hmax <- -sum((xy$counts / ntot) * log2(xy$counts/ntot))#
#
calcmkl <- function(mod_run, dp = NULL){#
    if (is.null(dp)){#
    dp <- default_prior(mod_run[[1]])#
        }#
    xout <- remix_mkldiv(mod_run[[2]], dp, plot.dens = FALSE,nbreaks = 101, minx = 0, maxx = 1)#
    return(xout)#
}
gulls_multirun[[1]]$gulls_in
gulls_multirun
rout <- map(1:length(gulls_multirun), ~calchell(gulls_multirun[[.x]]))
rdf <- do.call(rbind, rout) %>% data.frame() %>%#
setNames(paste0('hd', as.character(sdat$source))) %>%#
 cbind(dfin)#
#
kout <- map(1:length(gulls_multirun), ~calckl(gulls_multirun[[.x]]))#
#
kdf <- do.call(rbind, kout) %>% data.frame() %>%#
setNames(paste0('hk', as.character(sdat$source))) %>%#
 cbind(dfin) %>% left_join(rdf)#
#
vbout <- map(1:length(gulls_multirun), ~calcvarbia(gulls_multirun[[.x]]))#
vbdf <- do.call(rbind, vbout) %>% data.frame() %>%#
 cbind(dfin) %>% left_join(kdf)
kmvout <- map(1:length(gulls_multirun), ~calcmkl(gulls_multirun[[.x]]))
kmvdf <- do.call(rbind, kmvout) %>% data.frame() %>%#
 cbind(dfin) %>% left_join(vbdf)
kmvdf
head(kmvdf)
head(vbdf)
rdsum <- kmvdf %>% group_by(n, sdmult) %>%#
summarize_all(funs(mean, sd)) %>% select(-contains("seed"))
warnings()
kmvdf %>% group_by(n, sdmult)
head(kmvdf)
class(kmvdf$hdist)
str(kmvdf$hdist)
str(kmvout)
kmvout[[1]]
str(kmvout[[1]])
kmvout[[1]][1]
kmvout[[1]][[1]]
kmvdf <- kmvout %>% map(~pluck(.x, "kldist")) %>%#
    unlist(kmvout) %>% data.frame() %>%#
    setNames("mvkld") %>% cbind(dfin) %>% left_join(vbdf)
head(kmvdf)
str(kmvdf$mvkld)
kmvdf <- kmvout %>% map(~pluck(.x, c("kldist", "hdist"))) %>%#
    unlist(kmvout) %>% data.frame() %>%#
    setNames("mvkld") %>% cbind(dfin) %>% left_join(vbdf)
?pluck
kmvout %>% map(~pluck(.x, "kldist")) %>%#
    unlist(kmvout)
kld
kmvout %>% map(~pluck(.x, "kldist")) %>%#
    unlist(kmvout)
hdist <- kmvout %>% map(~pluck(.x, "hdist")) %>%#
    unlist(kmvout)
hdist
kld <- kmvout %>% map(~pluck(.x, "kldist")) %>%#
    unlist(kmvout)#
hdist <- kmvout %>% map(~pluck(.x, "hdist")) %>%#
    unlist(kmvout)#
kmvdf <-  data.frame(hdist = hdist, mvkld = kld) %>%#
    cbind(dfin) %>% left_join(vbdf)
rdsum <- kmvdf %>% group_by(n, sdmult) %>%#
summarize_all(funs(mean, sd)) %>% select(-contains("seed"))
rdsum
ggplot(rdsum, aes(x = n, y = hdist_mean,color = sdmult)) + geom_point()
datforplots <- list(basic = rdsum)
gpd <- drawpriors(gulls_multirun_infprior[[1]]$dat_in,  ginfprior)#
#
Hmax_inf <- rep(NA, 3)#
for(i in 1:3){#
    xy <- hist(gpd[,i], breaks = 101, plot = F)#
    ntot <- sum(xy$counts)#
    Hmax_inf[i] <- -sum(na.omit((xy$counts / ntot) * log2(xy$counts/ntot)))#
}
rout <- map(1:length(gulls_multirun_infprior), ~calchell(gulls_multirun_infprior[[.x]], dp = ginfprior))#
rdf <- do.call(rbind, rout) %>% data.frame() %>%#
setNames(paste0('hd', as.character(sdat$source))) %>%#
 cbind(dfin2)#
#
kout <- map(1:length(gulls_multirun_infprior), ~calckl(gulls_multirun_infprior[[.x]], dp = ginfprior))#
#
kdf <- do.call(rbind, kout) %>% data.frame() %>%#
setNames(paste0('hk', as.character(sdat$source))) %>%#
 cbind(dfin2) %>% left_join(rdf)#
#
vbout <- map(1:length(gulls_multirun_infprior), ~calcvarbia(gulls_multirun_infprior[[.x]]))#
vbdf <- do.call(rbind, vbout) %>% data.frame() %>%#
 cbind(dfin2) %>% left_join(kdf)
kmvout <- map(1:length(gulls_multirun_infprior), ~calcmkl(gulls_multirun_infprior[[.x]]))#
 kld <- kmvout %>% map(~pluck(.x, "kldist")) %>%#
     unlist(kmvout)#
 hdist <- kmvout %>% map(~pluck(.x, "hdist")) %>%#
     unlist(kmvout)#
 kmvdf <-  data.frame(hdist = hdist, mvkld = kld) %>%#
     cbind(dfin2) %>% left_join(vbdf)
rdsum <- kmvdf %>% group_by(n) %>%#
summarize_all(funs(mean, sd)) %>% select(-contains("seed"))
rdsum
datforplots <- c(datforplots, list(infprior = rdsum))
rout <- map(1:length(gulls_multirun_biased), ~calchell(gulls_multirun_biased[[.x]]))#
rdf <- do.call(rbind, rout) %>% data.frame() %>%#
setNames(paste0('hd', as.character(sdat$source))) %>%#
 cbind(dfin2)#
#
kout <- map(1:length(gulls_multirun_biased), ~calckl(gulls_multirun_biased[[.x]]))#
#
kdf <- do.call(rbind, kout) %>% data.frame() %>%#
setNames(paste0('hk', as.character(sdat$source))) %>%#
 cbind(dfin2) %>% left_join(rdf)#
#
vbout <- map(1:length(gulls_multirun_biased), ~calcvarbia(gulls_multirun_biased[[.x]]))#
vbdf <- do.call(rbind, vbout) %>% data.frame() %>%#
 cbind(dfin2) %>% left_join(kdf)#
#
 kmvout <- map(1:length(gulls_multirun_biased), ~calcmkl(gulls_multirun_biased[[.x]]))#
 kld <- kmvout %>% map(~pluck(.x, "kldist")) %>%#
     unlist(kmvout)#
 hdist <- kmvout %>% map(~pluck(.x, "hdist")) %>%#
     unlist(kmvout)#
 kmvdf <-  data.frame(hdist = hdist, mvkld = kld) %>%#
     cbind(dfin2) %>% left_join(vbdf)#
rdsum <- kmvdf %>% group_by(n) %>%#
summarize_all(funs(mean, sd)) %>% select(-contains("seed"))#
#
datforplots <- c(datforplots, list(biased = rdsum))
save(datforplots,#
    file = "isotope mixing models/remixsiar/data-raw/sims/GullsSummary.rda")#
hmax <- list(Hmax = Hmax, Hmax_inf = Hmax_inf)
load("/Users/s2973410/Code/BenthicLatent/data-raw/area_reef_change.rda")
datareas
# ---------------#
# Prepare baselayers for mapping#
# ---------------#
# CJ Brown 16 Jun 2017#
# This version just uses inverse probit transform#
#
rm(list = ls())#
library(devtools)#
library(jagstools)#
library(tidyr)#
library(PlotTools)#
library(dplyr)#
library(sp)#
library(rgdal)#
library(raster)#
library(RColorBrewer)#
library(png)#
library(maptools)#
library(purrr)#
#
# ---------------#
# Parameters#
# ---------------#
#Quantiles for area affected#
quants <- c(0.95, 0.75, 0.5, 0.25)#
#
# ---------------#
# Load data#
# ---------------#
#
load_all('~/Code/BenthicLatent')#
data(lv_input)#
data(gdist)#
setwd('/Users/s2973410/Code/BenthicLatent/data-raw')#
#
sitesdf <- read.csv('JuvUVCSites_with_ReefTypes_16Jun2016.csv')#
#
num_levels <- 2#
savname <- paste0('BLM_numlv', num_levels,'_v3.RData')#
load(savname)#
#
reefs <- readOGR("Kia reefs", "Reef_Strata_Kia")#
land <- readOGR("LandPoly", "LandPoly")#
ponds <- readOGR("Kia_Logging_Ponds", "Kia_Logging_Ponds")#
landuse <- raster('GRID_sol_update/sol_update')#
#
SI <- readOGR("SI_admin", "SLB_adm1") #shapefile of SI#
# see http://www.diva-gis.org/datadown to download this.#
SI <- rgeos::gSimplify(SI, 0.01)#
#
narr <- readPNG("north-arrow-2.png")#
arrrat <- dim(narr)[1]/dim(narr)[2]#
#
#New log ponds#
newponds <- data.frame(rbind(c(-7.43639, 158.19973), c(-7.42830, 158.20321), c(-7.42558, 158.20111)))#
coordinates(newponds) <- ~X2 + X1#
proj4string(newponds) <- CRS('+init=epsg:4326')#
newpondsutm <- spTransform(newponds, crs(land))#
#
##
# Filter and transform reefs#
##
juvhab <- c('Lagoon exposed fringing - reef flat', 'Intra-lagoon patch-reef complex - subtidal reef flat')#
reefs2 <- spTransform(reefs, CRS(proj4string(ponds))) %>%#
    subset(C_L3Att_L4 %in% juvhab)#
#plot(reefs2)#
#plot(land, col = "wheat")#
#plot(ponds, col = 'red', add = T)#
#plot(landuse)#
#
# ---------------#
# Distance raster#
# ---------------#
#
##
# Code to estimate distances#
##
#
#landsea <- landuse#
#landsea[landuse ==7 | landuse ==4] = 1#
#landsea[landuse !=7 & landuse !=4] = NA#
# plot(landsea, maxpixels = 5000)#
#ls2 <- aggregate(landsea, fact = 5)#
#ls2 <- landsea#
#iloc <- cellFromXY(ls2, ponds)#
#ls2[iloc] <- 2#
#ls3 <- ls2#
#iloc2 <- cellFromXY(ls3, newpondsutm)#
#ls3[iloc2] <- 2#
#takes about 30 seconds for full res, <1 second for aggregation at factor 5#
#system.time(gdist2 <- gridDistance(ls3, origin = 2, omit  = NA))#
#devtools::use_data(gdist2, pkg = "~/Code/BenthicLatent")#
#
##
# Here's a distane layer prepared earlier#
##
data(gdist2)#
plot(gdist)#
plot(reefs2, add = T)#
#
dev.new()#
plot(gdist2)#
plot(reefs2, add = T)#
#
rreef <- rasterize(reefs2, gdist)#
rreefdist <- mask(gdist, rreef)#
#
plot(rreefdist)#
#
# ---------------#
# Distance layer#
# ---------------#
#
#Transform distances to same scale as used in model#
rX1 <- (gdist - lv_input$mndist)/lv_input$sddist#
xfrommodel <- lv_input$mindists#
gmax <- max(xfrommodel)#
gmin <- min(xfrommodel)#
rX1[rX1 > gmax] <- gmax#
rX1[rX1 < gmin] <- gmin#
plot(rX1)#
plot(reefs2, add = T)#
#
#Distances for new log ponds#
rX1new <- (gdist2 - lv_input$mndist)/lv_input$sddist#
rX1new[rX1new > gmax] <- gmax#
rX1new[rX1new < gmin] <- gmin#
plot(rX1new)#
plot(reefs2, add = T)#
#
#Check Transform#
plot(raster::extract(rX1, cbind(sitesdf$coordx, sitesdf$coordy)), xfrommodel)#
abline(0,1)#
#
# -------------------#
# Bayes model params#
# -------------------#
colnams <- dimnames(mcout3[[1]])[[2]]#
igam <- stringr::str_detect(colnams, '\\bgamma\\b')#
igamf <- stringr::str_detect(colnams, 'gammaf')#
mcmat <- as.matrix(mcout3[[1]])#
gamma1 <-  mcmat[,igam]#
gammaf <- mcmat[,igamf]#
gmode <- quantile(gamma1, 0.5)#
g025 <- quantile(gamma1, 0.025)#
g975 <- quantile(gamma1, 0.975)#
gfmode <- quantile(gammaf, 0.5)#
#
head(mcout3[[1]])#
#
# ---------------#
# Predict latent variable spatially#
# ---------------#
#
##
# Conceptual dev#
##
dseq <- seq(gmin, gmax, length.out = 10)#
px <- 1 - pnorm(gmode * dseq, mean = 0, sd = 1)#
px2 <- 1 - pnorm(g025 * dseq, mean = 0, sd = 1)#
plot(2 * dseq ,1 - pnorm(2 * dseq, mean = 0, sd = 1), type = 'l', ylim = c(0,1), lwd = 2)#
lines(0.1 * dseq, 1 - pnorm(0.1 * dseq, mean = 0, sd = 1), col = "red", lty = 2, lwd = 2)#
points(gmode * dseq, px, col = "darkgreen", pch = 16)#
##
# Probit transfrom#
##
#
rprobit <- rprobit025 <- rprobit975 <- raster(rX1)#
rprobit[] <- 1 - pnorm(gmode * rX1[], mean = 0, sd = 1)#
rprobit025[] <- 1 - pnorm(g025 * rX1[], mean = 0, sd = 1)#
rprobit975[] <- 1 - pnorm(g975 * rX1[], mean = 0, sd = 1)#
#
rprobit_new <- rprobit_new025 <- rprobit_new975 <- raster(rX1)#
rprobit_new[] <- 1 - pnorm(gmode * rX1new[], mean = 0, sd = 1)#
rprobit_new025[] <- 1 - pnorm(g025 * rX1new[], mean = 0, sd = 1)#
rprobit_new975[] <- 1 - pnorm(g975 * rX1new[], mean = 0, sd = 1)#
#
plot(rprobit)#
plot(rprobit025)#
plot(rprobit975)#
#
# ---------------#
# Crop latent variable.#
# ---------------#
r2 <- mask(rprobit, rreef)#
r2_025 <- mask(rprobit025, rreef)#
r2_975 <- mask(rprobit975, rreef)#
r2new <- mask(rprobit_new, rreef)#
r2new_025 <- mask(rprobit_new025, rreef)#
r2new_975 <- mask(rprobit_new975, rreef)#
#
eregion <- extent(393286.9, 455857.4, 9136901, 9189922)#
rcrop <- crop(rprobit, eregion)#
rcropnew <- crop(rprobit_new, eregion)#
#
# ---------------#
# Estimates of area affected#
# ---------------#
nreefs <- sum(!is.na(r2[]), na.rm = T)#
(area1 <- map_dbl(quants, ~sum(r2[] >= .x, na.rm = T)/nreefs))#
(area1_025 <- map_dbl(quants, ~sum(r2_025[] >= .x, na.rm = T)/nreefs))#
(area1_975 <- map_dbl(quants, ~sum(r2_975[] >= .x, na.rm = T)/nreefs))#
#new reefs#
(areanew <- map_dbl(quants, ~sum(r2new[] >= .x, na.rm = T)/nreefs))#
(areanew_025 <- map_dbl(quants, ~sum(r2new_025[] >= .x, na.rm = T)/nreefs))#
(areanew_975 <- map_dbl(quants, ~sum(r2new_975[] >= .x, na.rm = T)/nreefs))#
#
#additional area affected, hectares:#
quants
(prod(res(r2new)) * nreefs * areanew)
(prod(res(r2new)) * nreefs * areanew)/10000
((prod(res(r2new)) * nreefs * areanew) - (prod(res(r2new)) * nreefs * area1)) / 10000
areanew
(prod(res(r2new)) * nreefs * area1)
(prod(res(r2new)) * nreefs * area1)/10000
area1
quants
citation("BenthicLatent")
load_all('~/Code/BenthicLatent/')
citation("BenthicLatent")
citation("BenthicLatent")
citation("BenthicLatent")
